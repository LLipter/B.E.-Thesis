% Chapter x

\chapter{改进空间}

\section{提升存储效率}

现阶段我们的程序会把用户所上传的每份文件都存储下来，供用户之后下载、浏览。然而这样有潜在的造成大量磁盘空间浪费的风险。试想同一份文件被无数用户分别上传，那么服务器就会存储上百个这份文件的拷贝，这是对磁盘资源的极大浪费，是及其低效的。

一个可行的改进方案是，通过计算文件的哈希散列值作为文件的唯一标识符。每份文件我们只会存储一份，无论有多少用户上传过它。同时技术上需要为每个文件增加一个计数器字段，用于记录当前一共有多少个用户拥有这份文件，当计数器清零的时候服务器端就可以删除该文件，释放磁盘空间。

同时，这样的方案能够自然地引出文件分享的功能，让文件在用户与用户之间更加便捷的传递。

\section{异步化方法提高响应效率}

我们已经利用了Spring Boot的@Async关键提升了发送电子邮件的效率，减少了用户需要等待的时间。而同样的操作还可以应用于用户更换密钥的时候（在主界面点击“CHANGE KEY”按钮）。因为更换密钥需要重新计算所有用户上传文件的数字签名，加密文件也需要先解密再重新加密。这样频繁的密码学运算相对而言是比较消耗CPU时间的，在用户上传的文件较多的情况下会大大地影响服务器端响应速度，摧毁用户体验。因此我们可以让这部分操作异步化，即服务器直接返回成功的提示信息，告知用户文件的数字签名等信息会在稍后几分钟内得到刷新。

\section{重用Cipher提高运算效率}

我们使用JCE提供的密码学相关函数进行种种密码学运算，其中要注意到的是我们大量的使用到了Cipher类的对象。而Cipher类的对象的初始化是比较消耗时间的，我们现在的解决方案是每次需要运算时都单独生成独立的Cipher类对象，运算完即抛弃。这样虽然代码实现简单，但却造成了Cipher对象的浪费，在密码学运算数量庞大的情况下会大大地增加运算压力。

一个可行的改进方案是，根据所用Cipher场景、种类的具体区别，构建多个Cipher缓存池。将Cipher对象的生成、初始化统一交由缓存池管理。所有请求在需要进行密码学运算的时候向缓存池请求Cipher对象，运行完成后归还Cipher对象。从而极大地减少创建Cipher对象、初始化Cipher对象的此处，提高重用度。