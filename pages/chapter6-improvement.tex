% Chapter 6

\chapter{改进空间}

\section{提升存储效率}

现阶段我们的程序会把用户所上传的每份文件都存储下来，供用户之后下载、浏览。然而这样有潜在的造成大量磁盘空间浪费的风险。试想同一份文件被无数用户分别上传，那么服务器就会存储上百个这份文件的拷贝，这是对磁盘资源的极大浪费，是及其低效的。

一个可行的改进方案是，通过计算文件的哈希散列值作为文件的唯一标识符。每份文件我们只会存储一份，无论有多少用户上传过它。同时技术上需要为每个文件增加一个计数器字段，用于记录当前一共有多少个用户拥有这份文件，当计数器清零的时候服务器端就可以删除该文件，释放磁盘空间。

同时，这样的方案能够自然地引出文件分享的功能，让文件在用户与用户之间更加便捷的传递。

\section{异步化方法提高响应效率}

我们已经利用了Spring Boot的@Async关键提升了发送电子邮件的效率，减少了用户需要等待的时间。而同样的操作还可以应用于用户更换密钥的时候（在主界面点击“CHANGE KEY”按钮）。因为更换密钥需要重新计算所有用户上传文件的数字签名，加密文件也需要先解密再重新加密。这样频繁的密码学运算相对而言是比较消耗CPU时间的，在用户上传的文件较多的情况下会大大地影响服务器端响应速度，摧毁用户体验。因此我们可以让这部分操作异步化，即服务器直接返回成功的提示信息，告知用户文件的数字签名等信息会在稍后几分钟内得到刷新。

\section{重用Cipher提高运算效率}

我们使用JCE提供的密码学相关函数进行种种密码学运算，其中要注意到的是我们大量的使用到了Cipher类的对象。而Cipher类的对象的初始化是比较消耗时间的，我们现在的解决方案是每次需要运算时都单独生成独立的Cipher类对象，运算完即抛弃。这样虽然代码实现简单，但却造成了Cipher对象的浪费，在密码学运算数量庞大的情况下会大大地增加运算压力。

一个可行的改进方案是，根据所用Cipher场景、种类的具体区别，构建多个Cipher缓存池。将Cipher对象的生成、初始化统一交由缓存池管理。所有请求在需要进行密码学运算的时候向缓存池请求Cipher对象，运行完成后归还Cipher对象。从而极大地减少创建Cipher对象、初始化Cipher对象的此处，提高重用度。

\section{HTTPS通信}

HTTPS通过通信双方点对点的加密协议，能够提供一个安全的信导，能够有效地阻止中间人攻击（Man in the Middle）。因此我们可以通过将HTTP协议提升至HTTPS协议的方式增加安全性。具体而言，我们需要首先获得一份SSL证书。这份证书可以是我们自己生成的，也可以是由受信任的CA发布的。然后我们需要启用Spring Boot中的HTTPS模式（如下图代码所示配置），并且将所有HTTP请求都重定向到HTTPS接口中。最后我们需要将自己的SSL证书发布给我们的用户们，方便用户通过HTTPS协议来验证我们的身份。

\begin{minted}
[
	frame=lines,
	framesep=2mm,
	baselinestretch=1.2,
	bgcolor=lightgray,
	fontsize=\footnotesize,
	linenos
]{java}

server.port=8443
server.ssl.key-store-type=PKCS12
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=password
server.ssl.key-alias=tomcat
security.require-ssl=true

\end{minted}

\section{加密层次结构的改进}

在我们现在的加密模式中，用户的主密钥还是存储在我们的服务器中的。在这种模式下，一旦我们程序的主密钥因为某种原因意外泄露了，恶意攻击者便掌握了任何用户的任何信息，恶意攻击者便可以解密任何用户加密的任何文件，并伪造任何用户的数字签名。

一个可行的改进方案是不存储用户的主密码，让主密码从用户设定的密码中推导得出。这样的优点是即便服务器遭到完整的泄露，程序主密码被恶意攻击者得知，用户的所有文件数据依然能保持安全。

就本质而言，这是把保证数据安全的责任从服务器端转移到了用户端。服务器不记录用户的主密钥，没有了保护的责任。而主密钥从用户的密码推导，用户必须全力保证自己的密码安全。

这样做的优点是整体系统的安全性得到了提升，缺点是用户的使用体验会下降——因为每一次需要用到用户主密钥的时候用户都必须重新输入一次密码。安全性与便捷性也是一组常常出现需要权衡的两个变量。同时我们还要注意到，在这样的体系下，一旦用户忘记了自己的秘密，我们没有任何可以帮助用户找回的方法。这样的后果是灾难性的，所有之前用户上传加密后的文件都将变得永远无法解密。用户对于密码的控制责任变得无比巨大。
